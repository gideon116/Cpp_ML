#version 450

layout(binding = 0) readonly    buffer buffer_X     { float X[]; };
layout(binding = 1) readonly    buffer buffer_W     { float W[]; };
layout(binding = 2) writeonly   buffer buffer_out   { float O[]; };

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform pc
{
    uint    inH, inW, inC, 
            kH, kW, outC, 
            outH, outW, 
            batch, 
            biasOffset;
};

uint index_A(uint b, uint hi, uint wi, uint ci)
{ return ((b * inH + hi) * inW + wi) * inC + ci; }

uint index_B(uint hk, uint wk, uint ci, uint co)
{ return ((hk * kW + wk) * inC + ci) * outC + co; }

uint index_C(uint b, uint ho, uint wo, uint co)
{ return ((b * outH + ho) * outW + wo) * outC + co; }

void main() {
    uint wioc   = gl_GlobalInvocationID.x;
    uint hi     = gl_GlobalInvocationID.y;
    uint bi     = gl_GlobalInvocationID.z;

    uint wi = wioc / outC;
    uint oc = wioc % outC;

    if (wi >= outW || hi >= outH || bi >= batch || oc >= outC) return;

    float temp = 0.0f;
    for (uint h2 = 0; h2 < kH; h2++)
        for (uint w2 = 0; w2 < kW; w2++)
            for (uint c2 = 0; c2 < inC; c2++)
                temp += X[index_A(bi, h2 + hi, w2 + wi, c2)] * W[index_B(h2, w2, c2, oc)];
    
    if (biasOffset != 0) 
        temp += W[biasOffset + oc];
    O[index_C(bi, hi, wi, oc)] = temp;

}